## 项目规范

* __[项目规范](standard.md)__ 
    * [文档说明](#文档说明)
    * [编程规约](#编程规约)
      * [命名风格](#命名风格)
      * [常量定义](#常量定义)
      * [代码格式](#代码格式)
      * [OOP规范](#OOP规范)
      * [控制语句](#控制语句)
      * [注释规约](#注释规约)
    * [Java特性规约](#)
      * [集合处理](#集合处理)
      * [并发处理](#并发处理)
    * [异常规范](#异常规范)
      * [分层异常处理](#分层异常处理)
      * [异常处理](#异常处理)
    * [日志规约](#日志规约)
      * [日志规约](#日志规约)
    * [版本管理](#版本管理)
    * [数据库分析](#数据库分析)
      * [数据库范式](#数据库范式)
      * [建表规约](#建表规约)
      * [索引规范](#索引规范)
      * [SQL语句](#SQL语句)
      * [ORM映射](#ORM映射)
      
## 项目规范
[回到顶部](#readme)  
******************************************************************************
### 文档说明
[回到顶部](#readme)  

《Java开发手册》标记说明
* √ :项目中使用并遵循  
* × :未使用规范  
* ? :项目未使用或存疑  
* ! :重要  
* ps:补充  
--------------------------------------------------------------------------------
《Effective Java》标记说明
* 第x条 XXXXX
********************************************************************************
### 编程规约:
[回到顶部](#readme)  
#### 命名风格
    * √ 1 :不以下划线或美元符号开始和结束
    * √ 2 :不使用中英文混合方式，不允许使用中文，除非通用的拼音，如alibaba
    * √ 3 :类名使用UpperCamelClass 但DO/BO/DTO/VO/AO/PO等除外
    * √!4 :方法名、参数名、变量名使用lowerCamelCase风格，必须遵循驼峰形式，包括POJO类型
    * √ 5 :常量命名全部大写，单词间用下划线隔开，不要嫌名字长
    * √!6 :抽象类命名使用Abstract或Base开头
           异常类使用Exception结尾
           测试类使用 类名Test
    * √ 7 :int[] array 括号位置
    * √!8 :POJO类型布尔变量不要加is前缀，否则会引起部分框架解析序列化错误
    * √ 9 :包名统一采用小写，包名采用单数形式  
           若类名有复数含义，类名可使用复数形式
    * √ 10:杜绝不规范的缩写，保持可读性
    * √ 11:使用尽量完整的单词组合来表达其意
    * √!12:若使用了设计模式，应该在命名是体现出设计模式，如Factory,Proxy,Observer
    * √ 13:接口类中的方法和属性不要加修饰符号（如public），并加上有效的Javadoc注释，尽量不要在接口定义变量
    
    * !!14:【面向接口编程】
           对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口
           内部实现类用Impl后缀与接口区别
               
    * √ ps:如果形容能力的接口，取对应的形容词（通常是-able）形式为接口名
    * √ 15:枚举类名使用Enum后缀，成员名使用大写加下划线
       
    * !!16:各层命名规约：
         1)Service/DAO层命名规约
         * 获取单个对象的方法-get 前缀
         * 获取多个对象的方法-list 前缀
         * 获取统计值的方法-count 前缀
         * 插入的方法-save / insert 前缀
         * 删除的方法-remove / delete 前缀
         * 修改的方法-update 前缀
         2)领域模型命名规约
         * 数据对象 xxxDO xxx为数据表名
         * 数据传输对象 xxxDTO xxx为业务领域相关的名称
         * 展示对象 xxxVO xxx为网页名称
         * POJO是DO/DTO/VO/BO 统称，禁止命名为xxxPOJO
#### 常量定义
    * √ 1 :不允许使用魔法值（未预先定义的常量）  如反例：String key="lifecat"+userid;    
    * √ 2 :long或Long初始赋值，使用大写L，如反例Long a = 2l , 无法区分l跟1    
    * √ 3 :不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护
           大而全的常量类，需要查找定位，不利于理解和维护，如HOST配置信息不要放在一个类中    
    * √ 4 :常量的复用层次5层：放置在对应目录的constant目录下。类内直接private static final    
    * √ 5 :如果变量仅在一个范围内变化，使用enum类型
#### 代码格式
    * √ 1 :大括号：若空，写成{}；左前不换行，左后右前换行，else不换行
    * √ 2 :括号和内部字符不空格       
    * √ 3 :if/for/while/switch/do 等保留字和括号之间空格
    * √ 4 :二目三目运算符左右加空格
    * √ 5 :采用4空格，不用tap       
    * √!6 :注释双斜线加空格 // 注释 
    * √!7 :单行字符不超过120，第二行缩进4空格，第三行开始不再缩进
           运算符与下文一起换行
           方法点符号与下文一起换行
           参数换行时，在逗号后进行
           在括号前不换行
    * √ 8 :方法参数，逗号后边必须加空格 (int a, int b)
    * √ 9 :换行符使用unix格式，不要使用Windows格式
    * √ 10:无需增加空格使上下文对齐       
    * √ 11:不同逻辑、不同语义、不同业务之间的代码插入一个空行     
#### OOP规范
    * √!1 :静态变量或静态方法，直接使用类名访问，生成类对象会增加成本              
    * √ 2 :所有覆写方法，必须加@override              
    * √ 3 :避免使用可变参数，避免使用Object参数
    * ? 4 :接口过时，必须使用@Deprecated注解，并说明新接口              
    * ? 5 :不能使用过时类或方法              
    * √ 6 :equals()方法易产生NPE异常    正例 "test".equals(obj)              
           应使用有值得对象来调用方法     反例 obj.equals("test")
    * √!7 :包装类对象进行比较，必须使用equals()，而不是==
           如Integer在（-128~127）直接从缓存取值，可以用==；若超出，在堆上产生，不能用==              
    * !!8 :POJO类型必须使用包装数据类型----数据查询结果可能为NULL，当自动拆箱可能有NPE风险
           RPC方法返回值和参数必须使用包装数据类型--调用失败返回默认值Int->0,Integer->null可表示额外信息
           所有局部变量使用基本数据类型           
    * √!9 :DO/DTO/VO等POJO类型，不要设定任何属性默认值              
    * ? 10:序列化相关 ?              
    * √!11:构造方法禁止加入任何业务逻辑，若有，则放在init()中              
    * √!12:POJO类型必须写toString()方法，若有继承，先调用super.toString()
    * √ 13:String.split()最后一个元素可能NULL 如"1,2,3,,"              
    * √ 14:同名方法放一起
    * √!15:类内方法定义顺序: 公有或保护方法 > 私有方法 > getter/setter              
    * √ 16:setter中，参数名称与成员变量名字一直，this.成员=变量
           getter/setter中，不要加入业务逻辑，会难以排查问题              
    * √ 17:循环体内，使用stringbulider的append方法
    * √!18:final使用情况：
           不允许被继承的类       如String
           不允许修改引用的域对象  如POJO的域变量
           不允许被重写的方法     如POJO的setter
           不允许运行过程中重新赋值的局部变量
           避免上下文使用同一个变量，可使用final强制重新定义一个变量
    * √ 19:慎用object.clone()拷贝
    * !!20:【严控访问范围】                     
           不允许外部直接new，构造方法private
           工具类不允许有public或default构造方法
           类非static成员变量，并且与子类共享，protected
           类非static成员变量，并且只在本类使用，private
           类static成员变量，只在本类使用，private
           static成员变量，必须考虑是否为final
           类成员方法只供类内部调用，必须是private
           类成员方法只对继承类公开，protected
#### 控制语句
    * √ 1 ;switch-case必须有break或return，必须有一个default块
    * √ 2 :单行代码也要有大括号
    * √!3 :高并发中，避免使用等于作为判断，可能导致击穿，应使用范围判断
    * √!4 :避免使用if-else进行判断，不要超过三层
           可以使用卫语句
           策略模式
           状态模式
    * √ 5 :不要在条件判断中执行复杂语句，可以赋给一个布尔变量，取个理解的名字
    * √ 6 :定义对象、获取数据库连接、try-catch，放在循环体外面
    * √ 7 :避免采用取反逻辑
    * ? 8 :接口入参保护 ？
    * √ 9 :需要进行参数检验：
           调用频次低的方法
           执行时间开销大的方法
           需要高稳定性与可用性的方法
           对外提供的接口
           敏感权限入口
    * √ 10:不需要进行参数检验
           被循环调用的方法
           靠近底层的方法，如DAO，应在高层检验
           private只被自己调用的方法，若传入参数确定不会有问题
#### 注释规约
    * √ 1 :类、类属性、类方法使用Javadoc规范，不得使用//
    * √ 2 :抽象方法、接口方法，必须用Javadoc注释
           说明返回值、参数、异常、功能等
    * √ 3 :类必须添加创建者和创建日期
    * √ 4 :方法内部单行注释，在上方// ，多行注释 使用/* */
    * √ 5 :枚举类型字段要有注释
    * √ 6 :英文说不清楚，不如用中文
    * √ 7 :修改代码时，要一起修改注释
    * √ 8 :若注释掉代码，说明原因
    * √ 9 :注释要明确，描述思路
    * √ 10:力求精简准确，语义清晰就不用注释了
    * √ 11:特殊注释   // TODO:(标记人，标记时间，预计处理时间)实际上是Javadoc标签
                    // FIXME:(标记人，标记时间，预计处理时间)错误，不能工作
******************************************************************************
### Java特性规约
[回到顶部](#readme)  
#### 集合处理  
    * √ 1 :只要重写equals()，必须重写hashCode()
           Set存储不重复对象，必须重写
#### 并发处理
    * √ 1 :获取单例对象需要保证线程安全，其中的方法也要保证，如采用双重加锁机制
******************************************************************************
### 异常规范
[回到顶部](#readme)  
#### 分层异常处理
* DAO层: 抛出细粒度异常
* Manager层: 使用catch(Exception e)捕获所有异常, 并throw new DAOException(e), 不需打印日志
* Service层: 捕获异常, 记录日志, 不可再向上抛出, 并进行错误页面处理
#### 异常处理 
    * √ 1 :能通过检查避免的运行时异常，要进行预检查
    * √ 2 :异常不要用来做流程控制、条件控制
    * √ 3 :catch分清稳定代码与非稳定代码，不要对大段无异常代码进行try-catch
    * √ 4 :捕获异常是为了处理它，不要什么都不做，那么请将它抛出到外层调用者
    * ? 5 :try中若有事务代码，catch后要回滚事务，rollback
    * √ 6 :finally对资源进行关闭
      ?    try-with-resources方式 ?
    * √!7 :finally中不能用return trt(return)-->finally 若存在，则try中的return被覆盖掉
    * √ 8 :捕获异常与抛出异常必须完全匹配，或捕获其父类
    * √!9 :方法的返回值可以为null，不强制返回空集合或者空对象等，必须添加注释说明什么情况下返回Null
    * √!ps:NPE是调用者的责任，即使被调用者返回空集合或空对象，也并非高枕无忧，也要判断NPE
    * √ 10:NPE: 必须检查NPE问题，可能各种情况都会导致NPE问题
    * ?!11:避免直接抛出运行时异常，推荐业界定义过的异常如 DAOException、ServiceException
           不允许直接抛出Exception或Throwable
    * √ 12:考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”
    * √ 13:避免出现重复代码，若修改，需修改所有副本，容易遗漏
              抽取共性方法，或者抽象公共类，或者将代码组件化
******************************************************************************
### 日志规约
[回到顶部](#readme)  
#### 日志规约 
    * √ 1 :不可直接使用日志系统log4j等的API，应依赖使用日志框架SLF4J
           import org.slf4j.Logger;
           import org.slf4j.LogerFactory
           private static final Logger logger = LoggerFactory.getLogger(this.class);
    * √ 2 :日志文件推荐至少保存15天，避免周频次的异常
    * ? 3 :拓展日志 ?
    * √!4 :对debug/info级别的日志输出，必须使用条件输出形式或占位符方式
           当级别不够时，若logger.info("1"+"2"...)仍然会进行拼接，浪费资源
           条件  :if(logger.isDebugEnabled()){输出}
           占位符 :logger.debug("aehwio{}",值)
    * ? 5 :避免重复打印日志，浪费磁盘资源，应设置 additivity=false
    * ? 6 :logger.success(参数对象 toString() + e.getMessage())
    * √!7 :生产环境禁止输出debug
           有选择输出info
           思考：这些日志真的有人看吗？这条日志能干什么？能解决问题吗？
    * √ 8 :可以使用warn记录用户参数输入错误，避免投诉
           error级别只记录系统逻辑出错，异常等重要信息
******************************************************************************  
